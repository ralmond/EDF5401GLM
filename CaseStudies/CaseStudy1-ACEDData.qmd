---
title: "ACED Data"
format: html
---

# About ACED

ACED stands for Adaptive Content and Evidence-based Diagnosis.  It was
an intelligent tutoring system built by Val Shute and others
[@FatHog,@shute2006].  It's domain was algebraic sequences, although only the geometric sequences branch was involved in the field trials. 

## ACED Tasks and Feedback

ACED uses extended constructed response items or tasks.

![Sample ACED Item](img/ACEDitem.jpg)

For each item, if the student got the item wrong they could be provided with
elaborated feedback.

![Sample Item Feedback](img/ACEDfeedback.jpg)

## Bayesian Network Scoring Engine

As the students are solving problems, they're abilities can be measured
as the network goes on.  The scoring model is a Bayesian network [@bninea]. 
The specific Bayesian network used in ACED is shown below.

![ACED Competency Model](img/ACEDmodel.png)

In this Bayesian network, each node in the graph corresponds to a (latent)
variable which takes on one of the values _high_, _medium_ or _low_.  The
Bayes net produces a probability distribution over the latent variable.  

The columns `P.sgp..H`, `P.sgp..M` and `P.sgp..L` give the probabilities of 
the that the student is in the _high_, _medium_ or _low_ state.  The
expected value, `EAP.sgp` (expected a posteriori, solve geometric problems)
is computed by assigning _high = 1_, _medium = 0_ and _low = -1_, and then
taking the expected value, 
`EAP.sgp <- 1*P.sgp..H + 0*P.sgp..M + -1*P.sgp..L`.

The other EAP variables represent the other variables in the model.

One advantage of using a model like a Bayesian network is that it can
estimate the student's ability using only part of the data.  It can also
calculate for any item its _expected weight of evidence_ [@bninea], the
predicted amount of information the item could provide about the target
node in the network (_Solve Geometric Problems_).  

## Pretest and posttest

In addition to the ACED items, there is also a 25 item pretest and 
post-test.  More about this in another case study.

## The experiment

Around 300 (slightly less, after restricting the sample to the subjects 
for which consent and assent were obtained) middle school students 
participated in the study.  Arithmetic sequences were part of the normal
math curriculum, but geometric sequences were not.

The students were split into four groups:

A. Full feedback/adaptive sequence.  The full feedback was turned on
and the expected weight of evidence algorithm is used to make a custom
sequence for each student.

B. Accuracy-only feedback/adaptive sequence.  Instead of the full feedback,
the student is only told that their solution is correct or incorrect.  The
same adaptive sequence algorithm is used.

C. Full feedback/linear sequence.  The full feedback was turned on, but the same  fixed (linear) sequence of items is used for all students in this
group.

D. Control.  These students took the pretest and post-test, but did 
independent study while other students were using ACED.

This is an incomplete factorial design (i.e., we have two factors,
but the accruacy only/linear sequence condition is replaced with the
control).

## The research questions

1. Do the pretest, posttest and internal game measures measure the same thing?  (Validity and Reliability)

2. Does using ACED increase students understanding of algebraic sequences?

3. Do feedback and/or adaptive sequencing affect the amount of learning?

The first can be answered with simple regression.  The last two can be
answered with a technique called the analysis of covariance (ANCOVA).

# Loading R packages

R functions (and data) are bundled together in _packages_.  Various
statisticians have produced packages to extend the abilities of R.
A complete list of these packages (there are a whole lot) can be found on
[CRAN](https://cran.r-project.org/).

We will use two:  `DescTools` and `tidyverse`.

`DescTools` has a bunch of tools for descriptive statistics.  The
meta-package `tidyverse` loads a bunch of tools which make R syntax a 
little bit closer to how statisticians think about data. @r4ds2e explores
these in detail.  

## Installing packages

R comes with a bunch of core packages which perform many analyses.
Additional packages need to be downloaded from the repository (CRAN, 
one of its mirrors, or a non-CRAN repository like Bioconductor or
R-Universe).  Copying the package files from the repository to the local 
machine is called installation.  This only needs to be done once, but
packages might need to be updated if a new version of the package (or R)
is released.

There are two ways to install packages:  using RStudio and using R.  

Using RStudio, select `Tools > Install Packages ...` and put in the name
of the packages you want to install.

The second way is to call the `install.packages` function in R.  

```{r installation}
## Skip this step if packages are already installed.
if (length(find.package(c("tidyverse","DescTools"))) < 2L) {
  ## Set the repos field to avoid having R prompt you to select a mirror.
  install.packages(c("tidyverse","DescTools"),
                   repos="https://cloud.r-project.org/")
}
```

## Using the package

Once the package is installed, it can be used.  First, we can specify that
we want the function from a specific package by putting the package name
and `::` in front of the function name.  For example, `DescTools::Cor()`
refers to the function `Cor()` in the `DescTools` package, while 
`stats::cor()` is the similar function in the core `stats` package.

If we are going to use the package a lot, we can attach it the list of
packages R searches for functions, by using the function `library()`.
The function `search()` shows which packages are currently attached.

```{r search}
search()
```

Calling `library()` adds new packages to the search list.
```{r library}
library(DescTools)
library(tidyverse)
search()
```

It is very common to have a couple of calls to `library()` at the start
of each analysis script.

## Getting help on functions and packages.

The function `help(`_functionname_`)` will give information about a 
function.  This is abbreviated `?`_functionname_.

```{r help}
help("Cor")
```

Note that in R Studio, there is a tab in which help it appears.  Note that
at the bottom of the help is an example of the command in action, which you
can run to see how it works.

You can get help on the whole package by calling `help(package="XXX")`.

```{r helpPack}
help(package="DescTools")
```

Finally, you should credit the package authors.  You can find the right way
to do this using the `citation()` function.
```{r citation}
citation()
citation("DescTools")
citation("tidyverse")
```

# Loading the Data


## Importing the data

The functions `base::read.csv()` and `readr::read_csv()` will read a
a comma separated value (csv) file.

The function `summary()` shows a description of the variables.

The function `head()` shows the first couple of lines.

```{r loadACED}
ACEDextract <- read_csv("ACED_extract1.csv")
```

## Viewing the data

A couple of ways to view the data.

`summary()` gives a summary.

```{r summary}
summary(ACEDextract)
```

`head()` shows the first couple of lines.
```{r head}
head(ACEDextract)
```

In RStudio, you can also use `view()` to open a viewer window, or find
the variable name in the environment tab.

Just typing the name of the variable will dump it all out.  That is
usually a mistake if there are a lot of cases.  But in RStudio, it 
give you a nice interactive browser.

```{r dump,eval=FALSE}
ACEDextract
```


## A quick note on subsetting

We can use the expression `X[i,j]` to extract a single value.

Can also use vectors to get subsets.

```{r subset}
ACEDextract[1,1]
ACEDextract[1:10,c("SubjID","Cond_code")]
```

Tibbles and data.frames behave somewhat differently here.  Selecting a 
single value from a data frame gives a scalar (actually, vector of
length 1), but from a tibble, gives a tibble of size 1 by 1.  Use
`as.numeric()` or `as.character()` to convert to a vector.

```{r as.character}
as.character(ACEDextract[1,1])
```

### Selecting variables

Variables can be extracted by leaving the rows blank.  A single
variable can be extracted using the `$` operator.

```{r getval}

```

It can also be done using the tidyverse `select` (multiple variables)
of `pull` (single variable).

```{r select}

```

### Selecting cases

Frequently, we want to identify a subset of cases based on some logical
condition.

We can use a logical subscript to do this.


We can also use the `filter()` function.

### Chaining data wrangling steps.

The pipe operator `%>%` (from the `magrittr` package) allows chaining
the output of one command to another.

Often used with `->` assignment to specify where to save the output.


:::{.callout-caution}
The `%>%` operator needs to be the last thing on the line, not the
first on the next line.
:::


# Cleaning the Data

## Missing Data

## Coding categorical variables

## Making a gain score

# Marginal Summaries

## Descriptive Summaries

## Histograms and Density Plots

## Boxplots, Dot Plots and Violin Plots

# Two-way Summaries

## Scatterpot

## Facetted Plots

## Correlation Matrix

## Scatterplot Matrix
